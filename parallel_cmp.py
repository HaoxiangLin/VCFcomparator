#!/usr/bin/env python

import argparse
import vcf
import sys
import vcfcomparator as vc
from multiprocessing import Process, Queue
from re import sub
from os import remove
from os.path import basename
from time import sleep
from itertools import izip

def merge_vcfs(files, outname, outdir=None, verbose=False):
    assert len(files) > 0
    assert outname.endswith('vcf')

    if outdir is None:
        outname  = basename(outname)
    else:
        outname = outdir + "/" + basename(outname)

    template = vcf.Reader(filename=files[0])
    vcfout   = vcf.Writer(file(outname, 'w'), template)

    for infile in files:
        assert infile.endswith('vcf')
        if verbose:
            sys.stderr.write("merging " + infile + " into " + outname + "\n")
        vcfin = vcf.Reader(filename=infile)
        for rec in vcfin:
            vcfout.write_record(rec)
    vcfout.close()

    for infile in files:
        remove(infile)

def main(args):
    np = int(args.procs)
    assert np > 0

    rAB_list = []
    rBA_list = []

    processes = []
    seglists = vc.split_genome(args.fai, np, verbose=args.verbose)

    result_queue = Queue()
    vcfA_queue = Queue()
    vcfB_queue = Queue()

    segnum = 0
    mp=True
    for seglist in seglists:
        processes.append(Process(target=vc.runList, args=(result_queue, vcfA_queue, vcfB_queue, args, seglist, segnum, mp)))
        segnum += 1

    for p in processes:
        p.start()

    ''' dequeue jobs as they finish to avoid filling up the queue (see http://http://bugs.python.org/issue8426) '''

    dequeued_summaries = []
    dequeued_vcfA      = []
    dequeued_vcfB      = []

    dequeued_jobs = 0
    while dequeued_jobs < np * 3:
        while not result_queue.empty():
            dequeued_summaries.append(result_queue.get())
            dequeued_jobs += 1
            if args.verbose:
                sys.stderr.write("debug info: dequeued #" + str(dequeued_jobs) + " from result_queue.\n")
        while not vcfA_queue.empty():
            dequeued_vcfA.append(vcfA_queue.get())
            dequeued_jobs += 1
            if args.verbose:
                sys.stderr.write("debug info: dequeued #" + str(dequeued_jobs) + " from vcfA_queue.\n")
        while not vcfB_queue.empty():
            dequeued_vcfB.append(vcfB_queue.get())
            dequeued_jobs += 1
            if args.verbose:
                sys.stderr.write("debug info: dequeued #" + str(dequeued_jobs) + " from vcfB_queue.\n")
        sleep(5)

    summaries = {}
    for s in dequeued_summaries:
        for vtype in s.keys():
            if vtype not in summaries:
                summaries[vtype] = s[vtype]
            else:
                summaries[vtype].add(s[vtype])

    print "-"*60
    for vtype in summaries.keys():
        print summaries[vtype].output()
    print "-"*60

    sys.stdout.flush()

    if not args.skip_merge:
        vcfA_matched_files   = []
        vcfA_unmatched_files = []
        vcfB_matched_files   = []
        vcfB_unmatched_files = []

        vcfA_matched_outname   = sub('vcf.gz$', 'matched.vcf', args.vcf[0])
        vcfA_unmatched_outname = sub('vcf.gz$', 'unmatched.vcf', args.vcf[0])
        vcfB_matched_outname   = sub('vcf.gz$', 'matched.vcf', args.vcf[1])
        vcfB_unmatched_outname = sub('vcf.gz$', 'unmatched.vcf', args.vcf[1])

        sys.stderr.write("merging VCFs...\n")

        for (vcfA_matched, vcfA_unmatched), (vcfB_matched, vcfB_unmatched) in izip(dequeued_vcfA, dequeued_vcfB):
            vcfA_matched_files.append(vcfA_matched)
            vcfA_unmatched_files.append(vcfA_unmatched)
            vcfB_matched_files.append(vcfB_matched)
            vcfB_unmatched_files.append(vcfB_unmatched)

        merge_vcfs(vcfA_matched_files, vcfA_matched_outname, outdir=args.outdir, verbose=args.verbose)
        merge_vcfs(vcfA_unmatched_files, vcfA_unmatched_outname, outdir=args.outdir, verbose=args.verbose)
        merge_vcfs(vcfB_matched_files, vcfB_matched_outname, outdir=args.outdir, verbose=args.verbose)
        merge_vcfs(vcfB_unmatched_files, vcfB_unmatched_outname, outdir=args.outdir, verbose=args.verbose)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Compares two sorted VCF files and (optionally) masks regions.')
    parser.add_argument(metavar='<vcf_file>', dest='vcf', nargs=2, help='tabix-indexed files in VCF format')
    parser.add_argument('-m', '--mask', dest='maskfile', default=None, help='tabix-indexed BED file of masked intervals')
    parser.add_argument('-o', '--outdir', dest='outdir', default=None, help='directory for output')
    parser.add_argument('-t', '--truth', dest='truth', default=None, help='also compare results to a "truth" VCF (should be sorted and tabix-indexed)')
    parser.add_argument('-f', '--fai', dest='fai', required=True, help='.fai file generated by samtools faidx')
    parser.add_argument('-p', '--procs', dest='procs', default=1, help='number of jobs')
    parser.add_argument('-u', '--summary', dest='summary_outfile', default=None, help='outfile for summary (default stdout)')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='verbose mode for debugging')
    parser.add_argument('--skip_merge', action='store_true', default=False, help='skip VCF merge step')
    args = parser.parse_args()
    main(args)

